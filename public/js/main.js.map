{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/riot/riot.esm.js","webpack:///./src/helpers/config-helper.js","webpack:///./src/js/app.js","webpack:///./src/modules/app/app.riot","webpack:///./src/modules/content/content.riot"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","COMPONENTS_IMPLEMENTATION_MAP","Map","DOM_COMPONENT_INSTANCE_PROPERTY","PLUGINS_SET","Set","IS_DIRECTIVE","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","globals","freeze","domToArray","els","Array","isArray","test","toString","length","from","normalize","values","set","attrs","[object Object]","props","keys","forEach","el","prop","setAttribute","method","names","map","parseNodes","isFunction","panic","error","Error","callOrAssign","source","constructor","noop","this","options","assign","writable","configurable","normalizeAttribute","_ref2","string","replace","_","toUpperCase","defineProperties","properties","entries","_ref3","getName","element","tagName","toLowerCase","SIMPLE","bindingTypes","EACH","IF","TAG","SLOT","append","parent","children","start","end","before","insertBefore","fragment","ownerDocument","createDocumentFragment","appendChild","eqeq","a","b","identity","O","indexOf","moreNodes","moreStart","moreEnd","lessNodes","lessStart","lessEnd","compare","next","list","nextSibling","remove","removeChild","range","createRange","setStartBefore","setEndAfter","deleteContents","findK","ktr","j","lo","hi","mid","smartDiff","parentNode","futureNodes","futureStart","futureEnd","futureChanges","currentNodes","currentStart","currentEnd","currentChanges","currentLength","diff","live","currentIndex","has","applyDiff","rows","cols","v","k","pv","cv","pd","outer","diffIdx","OND","minLen","link","tresh","keymap","idxInOld","newi","oldi","prev","ptr","HS","EachBinding","seal","childrenMap","node","root","condition","evaluate","template","nodes","getKey","indexName","itemName","afterPlaceholder","placeholder","scope","parentScope","update","collection","items","newChildrenMap","batches","binding","item","index","context","extendScope","oldItem","Boolean","mustFilterItem","componentTemplate","clone","cloneNode","push","mount","delete","createPatch","currentSame","futureSame","isReversed","domdiff","patch","unmountRedundant","fn","redundant","info","pop","unmount","_ref","IfBinding","swap","mustMount","mustUnmount","inNode","outNode","ATTRIBUTE","expressionTypes","EVENT","TEXT","VALUE","REMOVE_ATTRIBUTE","SET_ATTIBUTE","attributeExpression","_ref6","oldValue","getMethod","normalizeValue","attributes","_ref5","setAllAttributes","attribute","removeAttribute","removeAllAttributes","normalizeValue$1","expressions","1","_ref7","2","_ref8","childNodeIndex","target","childNodes","val","nodeType","Node","COMMENT_NODE","textNode","document","createTextNode","replaceChild","data","3","expression","Expression","apply","type","create$2","SlotBinding","templateData","slots","find","_ref10","id","create$6","html","bindings","createDOM","moveSlotInnerContent","slot","firstChild","slotBindings","reduce","acc","_ref12","concat","TagBinding","tag","getComponent","component","slotsToMarkup","attr","getTag","_ref4","_ref9","0","offset","_ref13","4","_ref11","createDOMTree","owner","ownerSVGElement","isSvg","container","importNode","window","DOMParser","parseFromString","documentElement","creteSVGTree","createElement","innerHTML","content","createHTMLTree","SVG_RE","injectDOM","dom","moveChildren","TemplateChunk","bindingsData","createTemplateDOM","selector","redundantAttribute","querySelector","create$5","mustRemoveRoot","cleanNode","$","ctx","querySelectorAll","CSS_BY_NAME","getStyleNode","style","head","cssManager","css","inject","join","COMPONENT_CORE_HELPERS","COMPONENT_LIFECYCLE_METHODS","shouldUpdate","onBeforeMount","onMounted","onBeforeUpdate","onUpdated","onBeforeUnmount","onUnmounted","MOCKED_TEMPLATE_INTERFACE","createComponent","templateFn","components","componentTemplateFactory","camelToDashCase","createSubcomponents","componentAPI","defineComponent","state","preserveRoot","add","curry","_len","arguments","_key","_len2","args","_key2","enhanceComponentAPI","defaults","evaluateProps","attributeExpressions","DOMattributesToObject","computeState","oldState","newState","initialProps","runPlugins","updateValues","e","createAttributeBindings","addCssHook","newProps","filter","DOM_COMPONENT_INSTANCE_PROPERTY$1","COMPONENTS_IMPLEMENTATION_MAP$1","PLUGINS_SET$1","implementation","fns","f","g","compose","theComponent","plugin","app","Content","Carousel","Settings","getConfig","urls","duration","Nav","appData","App","mountApp","body"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"js/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* Riot v4.0.4, @license MIT */\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n      PLUGINS_SET = new Set(),\n      IS_DIRECTIVE = 'is',\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY,\n  PLUGINS_SET: PLUGINS_SET,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n\n/* eslint-disable fp/no-mutating-methods */\n/**\n * Throw an error\n * @param {string} error - error message\n * @returns {undefined} it's a IO void function\n */\n\nfunction panic(error) {\n  throw new Error(error);\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\n\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach((_ref) => {\n    let [key, value] = _ref;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n} // doese simply nothing\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\n\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return source;\n}\n/**\n * Normalize a DOM attribute that will be passed to a child component\n * @param   {string} attribute.name - attribute names might be dash case\n * @param   {*} attribute.value - sky is the limit\n * @returns {attribute} attribute object normalized\n */\n\nfunction normalizeAttribute(_ref2) {\n  let {\n    name,\n    value\n  } = _ref2;\n  return {\n    name: dashToCamelCase(name),\n    value: value\n  };\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach((_ref3) => {\n    let [key, value] = _ref3;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value\n    } = attribute; // spread attributes should be handled differently\n\n    if (!attribute.name) {\n      return Object.assign({}, acc, value);\n    }\n\n    const attr = normalizeAttribute({\n      value,\n      name: attribute.name\n    });\n    acc[attr.name] = attr.value;\n    return acc;\n  }, {});\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    const attr = normalizeAttribute(attribute);\n    acc[attr.name] = attr.value;\n    return acc;\n  }, {});\n}\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  const children = node.childNodes;\n  Array.from(children).forEach(n => node.removeChild(n));\n}\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n/* get rid of the @ungap/essential-map polyfill */\n\nconst append = (get, parent, children, start, end, before) => {\n  if (end - start < 2) parent.insertBefore(get(children[start], 1), before);else {\n    const fragment = parent.ownerDocument.createDocumentFragment();\n\n    while (start < end) fragment.appendChild(get(children[start++], 1));\n\n    parent.insertBefore(fragment, before);\n  }\n};\n\nconst eqeq = (a, b) => a == b;\n\nconst identity = O => O;\n\nconst indexOf = (moreNodes, moreStart, moreEnd, lessNodes, lessStart, lessEnd, compare) => {\n  const length = lessEnd - lessStart;\n  /* istanbul ignore if */\n\n  if (length < 1) return -1;\n\n  while (moreEnd - moreStart >= length) {\n    let m = moreStart;\n    let l = lessStart;\n\n    while (m < moreEnd && l < lessEnd && compare(moreNodes[m], lessNodes[l])) {\n      m++;\n      l++;\n    }\n\n    if (l === lessEnd) return moreStart;\n    moreStart = m + 1;\n  }\n\n  return -1;\n};\n\nconst isReversed = (futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare) => {\n  while (currentStart < currentEnd && compare(currentNodes[currentStart], futureNodes[futureEnd - 1])) {\n    currentStart++;\n    futureEnd--;\n  }\n\n  return futureEnd === 0;\n};\n\nconst next = (get, list, i, length, before) => i < length ? get(list[i], 0) : 0 < i ? get(list[i - 1], -0).nextSibling : before;\n\nconst remove = (get, parent, children, start, end) => {\n  if (end - start < 2) parent.removeChild(get(children[start], -1));else {\n    const range = parent.ownerDocument.createRange();\n    range.setStartBefore(get(children[start], -1));\n    range.setEndAfter(get(children[end - 1], -1));\n    range.deleteContents();\n  }\n}; // - - - - - - - - - - - - - - - - - - -\n// diff related constants and utilities\n// - - - - - - - - - - - - - - - - - - -\n\n\nconst DELETION = -1;\nconst INSERTION = 1;\nconst SKIP = 0;\nconst SKIP_OND = 50;\n\nconst HS = (futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges) => {\n  let k = 0;\n  /* istanbul ignore next */\n\n  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;\n  const link = Array(minLen++);\n  const tresh = Array(minLen);\n  tresh[0] = -1;\n\n  for (let i = 1; i < minLen; i++) tresh[i] = currentEnd;\n\n  const keymap = new Map();\n\n  for (let i = currentStart; i < currentEnd; i++) keymap.set(currentNodes[i], i);\n\n  for (let i = futureStart; i < futureEnd; i++) {\n    const idxInOld = keymap.get(futureNodes[i]);\n\n    if (idxInOld != null) {\n      k = findK(tresh, minLen, idxInOld);\n      /* istanbul ignore else */\n\n      if (-1 < k) {\n        tresh[k] = idxInOld;\n        link[k] = {\n          newi: i,\n          oldi: idxInOld,\n          prev: link[k - 1]\n        };\n      }\n    }\n  }\n\n  k = --minLen;\n  --currentEnd;\n\n  while (tresh[k] > currentEnd) --k;\n\n  minLen = currentChanges + futureChanges - k;\n  const diff = Array(minLen);\n  let ptr = link[k];\n  --futureEnd;\n\n  while (ptr) {\n    const {\n      newi,\n      oldi\n    } = ptr;\n\n    while (futureEnd > newi) {\n      diff[--minLen] = INSERTION;\n      --futureEnd;\n    }\n\n    while (currentEnd > oldi) {\n      diff[--minLen] = DELETION;\n      --currentEnd;\n    }\n\n    diff[--minLen] = SKIP;\n    --futureEnd;\n    --currentEnd;\n    ptr = ptr.prev;\n  }\n\n  while (futureEnd >= futureStart) {\n    diff[--minLen] = INSERTION;\n    --futureEnd;\n  }\n\n  while (currentEnd >= currentStart) {\n    diff[--minLen] = DELETION;\n    --currentEnd;\n  }\n\n  return diff;\n}; // this is pretty much the same petit-dom code without the delete map part\n// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561\n\n\nconst OND = (futureNodes, futureStart, rows, currentNodes, currentStart, cols, compare) => {\n  const length = rows + cols;\n  const v = [];\n  let d, k, r, c, pv, cv, pd;\n\n  outer: for (d = 0; d <= length; d++) {\n    /* istanbul ignore if */\n    if (d > SKIP_OND) return null;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n\n      r = c - k;\n\n      while (c < cols && r < rows && compare(currentNodes[currentStart + c], futureNodes[futureStart + r])) {\n        c++;\n        r++;\n      }\n\n      if (c === cols && r === rows) {\n        break outer;\n      }\n\n      cv[d + k] = c;\n    }\n  }\n\n  const diff = Array(d / 2 + length / 2);\n  let diffIdx = diff.length - 1;\n\n  for (d = v.length - 1; d >= 0; d--) {\n    while (c > 0 && r > 0 && compare(currentNodes[currentStart + c - 1], futureNodes[futureStart + r - 1])) {\n      // diagonal edge = equality\n      diff[diffIdx--] = SKIP;\n      c--;\n      r--;\n    }\n\n    if (!d) break;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n\n    if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n    }\n  }\n\n  return diff;\n};\n\nconst applyDiff = (diff, get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before) => {\n  const live = new Map();\n  const length = diff.length;\n  let currentIndex = currentStart;\n  let i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        futureStart++;\n        currentIndex++;\n        break;\n\n      case INSERTION:\n        // TODO: bulk appends for sequential nodes\n        live.set(futureNodes[futureStart], 1);\n        append(get, parentNode, futureNodes, futureStart++, futureStart, currentIndex < currentLength ? get(currentNodes[currentIndex], 0) : before);\n        break;\n\n      case DELETION:\n        currentIndex++;\n        break;\n    }\n  }\n\n  i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        currentStart++;\n        break;\n\n      case DELETION:\n        // TODO: bulk removes for sequential nodes\n        if (live.has(currentNodes[currentStart])) currentStart++;else remove(get, parentNode, currentNodes, currentStart++, currentStart);\n        break;\n    }\n  }\n};\n\nconst findK = (ktr, length, j) => {\n  let lo = 1;\n  let hi = length;\n\n  while (lo < hi) {\n    const mid = (lo + hi) / 2 >>> 0;\n    if (j < ktr[mid]) hi = mid;else lo = mid + 1;\n  }\n\n  return lo;\n};\n\nconst smartDiff = (get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before) => {\n  applyDiff(OND(futureNodes, futureStart, futureChanges, currentNodes, currentStart, currentChanges, compare) || HS(futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges), get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before);\n};\n/*! (c) 2018 Andrea Giammarchi (ISC) */\n\n\nconst domdiff = (parentNode, // where changes happen\ncurrentNodes, // Array of current items/nodes\nfutureNodes, // Array of future items/nodes\noptions // optional object with one of the following properties\n//  before: domNode\n//  compare(generic, generic) => true if same generic\n//  node(generic) => Node\n) => {\n  if (!options) options = {};\n  const compare = options.compare || eqeq;\n  const get = options.node || identity;\n  const before = options.before == null ? null : get(options.before, 0);\n  const currentLength = currentNodes.length;\n  let currentEnd = currentLength;\n  let currentStart = 0;\n  let futureEnd = futureNodes.length;\n  let futureStart = 0; // common prefix\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentStart], futureNodes[futureStart])) {\n    currentStart++;\n    futureStart++;\n  } // common suffix\n\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])) {\n    currentEnd--;\n    futureEnd--;\n  }\n\n  const currentSame = currentStart === currentEnd;\n  const futureSame = futureStart === futureEnd; // same list\n\n  if (currentSame && futureSame) return futureNodes; // only stuff to add\n\n  if (currentSame && futureStart < futureEnd) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentStart, currentLength, before));\n    return futureNodes;\n  } // only stuff to remove\n\n\n  if (futureSame && currentStart < currentEnd) {\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  }\n\n  const currentChanges = currentEnd - currentStart;\n  const futureChanges = futureEnd - futureStart;\n  let i = -1; // 2 simple indels: the shortest sequence is a subsequence of the longest\n\n  if (currentChanges < futureChanges) {\n    i = indexOf(futureNodes, futureStart, futureEnd, currentNodes, currentStart, currentEnd, compare); // inner diff\n\n    if (-1 < i) {\n      append(get, parentNode, futureNodes, futureStart, i, get(currentNodes[currentStart], 0));\n      append(get, parentNode, futureNodes, i + currentChanges, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n      return futureNodes;\n    }\n  }\n  /* istanbul ignore else */\n  else if (futureChanges < currentChanges) {\n      i = indexOf(currentNodes, currentStart, currentEnd, futureNodes, futureStart, futureEnd, compare); // outer diff\n\n      if (-1 < i) {\n        remove(get, parentNode, currentNodes, currentStart, i);\n        remove(get, parentNode, currentNodes, i + futureChanges, currentEnd);\n        return futureNodes;\n      }\n    } // common case with one replacement for many nodes\n  // or many nodes replaced for a single one\n\n  /* istanbul ignore else */\n\n\n  if (currentChanges < 2 || futureChanges < 2) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, get(currentNodes[currentStart], 0));\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  } // the half match diff part has been skipped in petit-dom\n  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397\n  // accordingly, I think it's safe to skip in here too\n  // if one day it'll come out like the speediest thing ever to do\n  // then I might add it in here too\n  // Extra: before going too fancy, what about reversed lists ?\n  //        This should bail out pretty quickly if that's not the case.\n\n\n  if (currentChanges === futureChanges && isReversed(futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare)) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n    return futureNodes;\n  } // last resort through a smart diff\n\n\n  smartDiff(get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before);\n  return futureNodes;\n};\n\nconst EachBinding = Object.seal({\n  // dynamic binding properties\n  childrenMap: null,\n  node: null,\n  root: null,\n  condition: null,\n  evaluate: null,\n  template: null,\n  nodes: [],\n  getKey: null,\n  indexName: null,\n  itemName: null,\n  afterPlaceholder: null,\n  placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder\n    } = this;\n    const collection = this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n    const parent = placeholder.parentNode; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    if (futureNodes.length) {\n      domdiff(parent, this.nodes, futureNodes, {\n        before: placeholder,\n        node: patch(Array.from(this.childrenMap.values()), parentScope)\n      });\n    } else {\n      // remove all redundant templates\n      unmountRedundant(this.childrenMap);\n    } // trigger the mounts and the updates\n\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    unmountRedundant(this.childrenMap, parentScope);\n    this.childrenMap = new Map();\n    this.nodes = [];\n    return this;\n  }\n\n});\n/**\n * Patch the DOM while diffing\n * @param   {TemplateChunk[]} redundant - redundant tepmplate chunks\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      const {\n        template,\n        context\n      } = redundant.pop(); // notice that we pass null as last argument because\n      // the root node and its children will be removed by domdiff\n\n      template.unmount(context, parentScope, null);\n    }\n\n    return item;\n  };\n}\n/**\n * Unmount the remaining template instances\n * @param   {Map} childrenMap - map containing the children template to unmount\n * @param   {*} parentScope - scope of the parent template\n * @returns {TemplateChunk[]} collection containing the template chunks unmounted\n */\n\n\nfunction unmountRedundant(childrenMap, parentScope) {\n  return Array.from(childrenMap.values()).map((_ref) => {\n    let {\n      template,\n      context\n    } = _ref;\n    return template.unmount(context, parentScope, true);\n  });\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? Boolean(condition(context)) === false : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref2) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref2;\n  scope[itemName] = item;\n  if (indexName) scope[indexName] = index;\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EeachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = oldItem ? componentTemplate.el : root.cloneNode();\n\n    if (!oldItem) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n\n\n    futureNodes.push(el); // delete the old item from the children map\n\n    childrenMap.delete(key); // update the children map\n\n    newChildrenMap.set(key, {\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create(node, _ref3) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref3;\n  const placeholder = document.createTextNode('');\n  const parent = node.parentNode;\n  const root = node.cloneNode();\n  const offset = Array.from(parent.childNodes).indexOf(node);\n  parent.insertBefore(placeholder, node);\n  parent.removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    offset,\n    condition,\n    evaluate,\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n/**\n * Binding responsible for the `if` directive\n */\n\n\nconst IfBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  placeholder: null,\n  template: '',\n\n  // API methods\n  mount(scope, parentScope) {\n    swap(this.placeholder, this.node);\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    switch (true) {\n      case mustMount:\n        swap(this.node, this.placeholder);\n\n        if (this.template) {\n          this.template = this.template.clone();\n          this.template.mount(this.node, scope, parentScope);\n        }\n\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        swap(this.placeholder, this.node);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    const {\n      template\n    } = this;\n\n    if (template) {\n      template.unmount(scope, parentScope);\n    }\n\n    return this;\n  }\n\n});\n\nfunction swap(inNode, outNode) {\n  const parent = outNode.parentNode;\n  parent.insertBefore(inNode, outNode);\n  parent.removeChild(outNode);\n}\n\nfunction create$1(node, _ref4) {\n  let {\n    evaluate,\n    template\n  } = _ref4;\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder: document.createTextNode(''),\n    template: template.createDOM(node)\n  });\n}\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst SET_ATTIBUTE = 'setAttribute';\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach((_ref5) => {\n    let [name, value] = _ref5;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing all the attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, attributes) {\n  Object.keys(attributes).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref6, value, oldValue) {\n  let {\n    name\n  } = _ref6;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    } else if (oldValue) {\n      // otherwise remove all the old attributes\n      removeAllAttributes(node, oldValue);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (typeof value === 'boolean') {\n    node[name] = value;\n  }\n\n  node[getMethod(value)](name, normalizeValue(name, value));\n}\n/**\n * Get the attribute modifier method\n * @param   {*} value - if truthy we return `setAttribute` othewise `removeAttribute`\n * @returns {string} the node attribute modifier method name\n */\n\n\nfunction getMethod(value) {\n  return value && typeof value !== 'object' ? SET_ATTIBUTE : REMOVE_ATTRIBUTE;\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  if (value === true) return name;\n  return value;\n}\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction eventExpression(node, _ref7, value) {\n  let {\n    name\n  } = _ref7;\n  node[name] = value;\n}\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {number} expression.childNodeIndex - index to find the text node to update\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction textExpression(node, _ref8, value) {\n  let {\n    childNodeIndex\n  } = _ref8;\n  const target = node.childNodes[childNodeIndex];\n  const val = normalizeValue$1(value); // replace the target if it's a placeholder comment\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode(val);\n    node.replaceChild(textNode, target);\n  } else {\n    target.data = normalizeValue$1(val);\n  }\n}\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\n\nfunction normalizeValue$1(value) {\n  return value != null ? value : '';\n}\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction valueExpression(node, expression, value) {\n  node.value = value;\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\nconst Expression = Object.seal({\n  // Static props\n  node: null,\n  value: null,\n\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    return this;\n  }\n\n});\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$2(node, data) {\n  return Object.assign({}, Expression, data, {\n    node\n  });\n}\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\n\n\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref9) {\n  let {\n    expressions\n  } = _ref9;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$2(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nconst SlotBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  name: null,\n  template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find((_ref10) => {\n      let {\n        id\n      } = _ref10;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    this.template = templateData && create$6(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      this.template.mount(this.node, parentScope);\n      moveSlotInnerContent(this.node);\n    }\n\n    parentNode.removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template && parentScope) {\n      this.template.update(parentScope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    if (this.template) {\n      this.template.unmount(parentScope);\n    }\n\n    return this;\n  }\n\n});\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLNode} slot - slot node\n * @returns {undefined} it's a void function\n */\n\nfunction moveSlotInnerContent(slot) {\n  if (slot.firstChild) {\n    slot.parentNode.insertBefore(slot.firstChild, slot);\n    moveSlotInnerContent(slot);\n  }\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} options.name - slot id\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref11) {\n  let {\n    name\n  } = _ref11;\n  return Object.assign({}, SlotBinding, {\n    node,\n    name\n  });\n}\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create$6(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref12) => {\n    let {\n      bindings\n    } = _ref12;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  name: null,\n  slots: null,\n  tag: null,\n  attributes: null,\n  getComponent: null,\n\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount() {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(true);\n    }\n\n    return this;\n  }\n\n});\n\nfunction create$4(node, _ref13) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref13;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$1,\n  [SIMPLE]: create$3,\n  [EACH]: create,\n  [TAG]: create$4,\n  [SLOT]: createSlot\n};\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {Object} binding - binding data\n * @returns {Expression} Expression object\n */\n\nfunction create$5(root, binding) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute); // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: expressions || []\n  }));\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n} // in this case a simple innerHTML is enough\n\n\nfunction createHTMLTree(html) {\n  const template = document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction creteSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return creteSVGTree(html, root);\n  return createHTMLTree(html);\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n// Ignore this helper because it's needed only for svg tags\n\n/* istanbul ignore next */\n\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n\nconst SVG_RE = /svg/i;\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {HTMLFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  if (SVG_RE.test(el.tagName)) {\n    moveChildren(dom, el);\n  } else {\n    el.appendChild(dom);\n  }\n}\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string} html - markup that will be injected into the root node\n * @returns {HTMLFragment} fragment that will be injected into the root node\n */\n\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  bindings: null,\n  bindingsData: null,\n  html: null,\n  dom: null,\n  el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html);\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope) {\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope);\n    this.el = el; // create the DOM if it wasn't created before\n\n    this.createDOM(el);\n    if (this.dom) injectDOM(el, this.dom.cloneNode(true)); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$5(this.el, binding));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean} mustRemoveRoot - if true remove the root element\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.el) {\n      this.bindings.forEach(b => b.unmount(scope, parentScope));\n\n      if (mustRemoveRoot && this.el.parentNode) {\n        this.el.parentNode.removeChild(this.el);\n      } else if (mustRemoveRoot !== null) {\n        cleanNode(this.el);\n      }\n\n      this.el = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {Array} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create$6(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  shouldUpdate: noop,\n  onBeforeMount: noop,\n  onMounted: noop,\n  onBeforeUpdate: noop,\n  onUpdated: noop,\n  onBeforeUnmount: noop,\n  onUnmounted: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = {\n  update: noop,\n  mount: noop,\n  unmount: noop,\n  clone: noop,\n  createDOM: noop\n  /**\n   * Factory function to create the component templates only once\n   * @param   {Function} template - component template creation function\n   * @param   {Object} components - object containing the nested components\n   * @returns {TemplateChunk} template chunk object\n   */\n\n};\n\nfunction componentTemplateFactory(template, components) {\n  return template(create$6, expressionTypes, bindingTypes, name => {\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {string} options.css - component css\n * @param   {Function} options.template - functon that will return the dom-bindings template function\n * @param   {Object} options.exports - component interface\n * @param   {string} options.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(_ref) {\n  let {\n    css,\n    template,\n    exports,\n    name\n  } = _ref;\n  const templateFn = template ? componentTemplateFactory(template, exports ? createSubcomponents(exports.components) : {}) : MOCKED_TEMPLATE_INTERFACE;\n  return (_ref2) => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    state: {}\n  })), Object.assign({\n    // defined during the component creation\n    slots: null,\n    root: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Evaluate the component properties either from its real attributes or from its attribute expressions\n * @param   {HTMLElement} element - component root\n * @param   {Array}  attributeExpressions - attribute values generated via createAttributeBindings\n * @returns {Object} attributes key value pairs\n */\n\nfunction evaluateProps(element, attributeExpressions) {\n  if (attributeExpressions === void 0) {\n    attributeExpressions = [];\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), evaluateAttributeExpressions(attributeExpressions));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$2(node, a));\n  const binding = {};\n\n  const updateValues = method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  };\n\n  return Object.assign(binding, {\n    expressions,\n    mount: updateValues('mount'),\n    update: updateValues('update'),\n    unmount: updateValues('unmount')\n  });\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, 'is', name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  const initialProps = callOrAssign(props);\n  return autobindMethods(runPlugins(defineProperties(Object.create(component), {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      this.props = Object.freeze(Object.assign({}, initialProps, evaluateProps(element, this[ATTRIBUTES_KEY_SYMBOL].expressions)));\n      this.state = computeState(this.state, state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      element[DOM_COMPONENT_INSTANCE_PROPERTY] = this; // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, 'root', element); // define the slots array\n\n      defineProperty(this, 'slots', slots); // before mount lifecycle event\n\n      this.onBeforeMount(this.props, this.state); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this.onMounted(this.props, this.state);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateProps(this.root, this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this.shouldUpdate(newProps, this.props) === false) return;\n      this.props = Object.freeze(Object.assign({}, initialProps, newProps));\n      this.state = computeState(this.state, state);\n      this.onBeforeUpdate(this.props, this.state);\n      this[TEMPLATE_KEY_SYMBOL].update(this, parentScope);\n      this.onUpdated(this.props, this.state);\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this.onBeforeUnmount(this.props, this.state);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount();\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, {}, !preserveRoot);\n      this.onUnmounted(this.props, this.state);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  PLUGINS_SET: PLUGINS_SET$1\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of nodes upgraded\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY$1]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY$1].unmount();\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET$1.has(plugin)) panic('This plugin was already install');\n  PLUGINS_SET$1.add(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET$1.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET$1.delete(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Helpter method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return (el, props) => compose(c => c.mount(el), c => c({\n    props\n  }), createComponent)(implementation);\n}\n/** @type {string} current riot version */\n\nconst version = 'v4.0.4'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, register, uninstall, unmount, unregister, version };\n","let theComponent;\n\n/**\n * GetConfig\n * Gets the value of a config field, or null if it does not exist\n *\n * @param {string} name - The name of the config value\n * @return {mixed} - The value\n */\nconst getConfig = (name) => {\n    const { app } = theComponent.props;\n    return app.data && app.data.options && typeof app.data.options[name] !== 'undefined'\n        ? app.data.options[name]\n        : null;\n};\n\n/**\n * Helper\n * The helper component\n *\n * @param {object} component - The component\n * @return {object} component - The modified component\n */\nconst helper = (component) => {\n    theComponent = component;\n    component.getConfig = getConfig;\n\n    return component;\n};\n\nexport default helper;\n","// NPM Dependencies\nimport { component, install } from 'riot';\nimport App from '../modules/app/app.riot';\nimport configHelper from '../helpers/config-helper.js';\n\n// Initialize\n((window, data) => {\n    const app = {\n        data\n    };\n\n    // Install helpers\n    install(configHelper);\n\n    // Register the app component.\n    const mountApp = component(App);\n\n    // Add the <app> tag and mount it.\n    const rootEl = document.body.appendChild(document.createElement('app'));\n    mountApp(rootEl, { app });\n})(window, appData);\n","<app>\n    <div class=\"main\">\n        <header>\n            <nav is=\"nav\" app={ props.app }></nav>\n        </header>\n        <main>\n            <div id=\"main-container\" class=\"container\">\n                <content app={ props.app }></content>\n            </div>\n        </main>\n        <footer>\n        </footer>\n    </div>\n    <script>\n        import Content from '../content/content.riot';\n        import Nav from '../nav/nav.riot';\n\n        export default {\n            components: {\n                Content,\n                Nav,\n            },\n        };\n    </script>\n</app>\n","<content>\n    <p>{ getConfig('basicText') }</p>\n    <section>\n        <carousel app={ props.app } urls={ urls } duration={ duration }></carousel>\n    </section>\n    <section>\n        <settings app={ props.app }></settings>\n    </section>\n    <script>\n        import Carousel from '../carousel/carousel.riot';\n        import Settings from '../settings/settings.riot';\n\n        export default {\n            components: {\n                Carousel,\n                Settings,\n            },\n        };\n    </script>\n</content>\n"],"sourceRoot":""}