{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/nanoajax/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/riot/riot.esm.js","webpack:///./src/components/carousel/carousel.riot","webpack:///./src/components/components/media-view/media-view.riot","webpack:///./src/components/content/content.riot","webpack:///./src/plugins/config-plugin.js","webpack:///./src/js/app.js","webpack:///./src/components/app/app.riot"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","global","reqfields","setDefault","obj","ajax","params","callback","headers","body","method","called","req","cors","XDomainRequest","test","navigator","userAgent","XMLHttpRequest","getRequest","cb","statusCode","responseText","undefined","status","response","open","url","success","onload","onreadystatechange","readyState","onerror","ontimeout","onabort","FormData","len","length","field","setRequestHeader","send","g","this","Function","e","window","COMPONENTS_IMPLEMENTATION_MAP","Map","DOM_COMPONENT_INSTANCE_PROPERTY","PLUGINS_SET","Set","IS_DIRECTIVE","VALUE_ATTRIBUTE","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","globals","freeze","SIMPLE","bindingTypes","EACH","IF","TAG","SLOT","append","parent","children","start","end","before","insertBefore","fragment","ownerDocument","createDocumentFragment","appendChild","eqeq","a","b","identity","O","indexOf","moreNodes","moreStart","moreEnd","lessNodes","lessStart","lessEnd","compare","next","list","nextSibling","remove","removeChild","range","createRange","setStartBefore","setEndAfter","deleteContents","findK","ktr","j","lo","hi","mid","smartDiff","parentNode","futureNodes","futureStart","futureEnd","futureChanges","currentNodes","currentStart","currentEnd","currentChanges","currentLength","diff","live","currentIndex","set","has","applyDiff","rows","cols","v","k","pv","cv","pd","outer","Array","diffIdx","OND","minLen","link","tresh","keymap","idxInOld","newi","oldi","prev","ptr","HS","EachBinding","seal","childrenMap","node","root","condition","evaluate","template","nodes","getKey","indexName","itemName","afterPlaceholder","placeholder","[object Object]","scope","parentScope","update","collection","items","from","newChildrenMap","batches","binding","forEach","item","index","context","_ref2","extendScope","oldItem","Boolean","mustFilterItem","componentTemplate","clone","el","cloneNode","push","mount","delete","createPatch","options","currentSame","futureSame","isReversed","domdiff","patch","values","unmountRedundant","fn","redundant","info","pop","unmount","map","_ref","IfBinding","swap","mustMount","mustUnmount","inNode","outNode","ATTRIBUTE","expressionTypes","EVENT","TEXT","VALUE","REMOVE_ATTRIBUTE","SET_ATTIBUTE","attributeExpression","_ref6","oldValue","getMethod","normalizeValue","attributes","entries","_ref5","setAllAttributes","keys","attribute","removeAttribute","removeAllAttributes","normalizeValue$1","expressions","1","_ref7","2","_ref8","childNodeIndex","target","childNodes","val","nodeType","Node","COMMENT_NODE","textNode","document","createTextNode","replaceChild","data","3","expression","Expression","apply","type","create$2","assign","SlotBinding","templateData","slots","find","_ref10","id","create$6","html","bindings","createDOM","moveSlotInnerContent","slot","firstChild","slotBindings","reduce","acc","_ref12","concat","TagBinding","tag","getComponent","component","slotsToMarkup","attr","getTag","_ref4","_ref9","0","_ref3","offset","_ref13","4","_ref11","createDOMTree","owner","ownerSVGElement","isSvg","container","importNode","DOMParser","parseFromString","documentElement","creteSVGTree","createElement","innerHTML","content","createHTMLTree","SVG_RE","injectDOM","dom","tagName","moveChildren","source","TemplateChunk","bindingsData","createTemplateDOM","Error","selector","redundantAttribute","querySelector","create$5","mustRemoveRoot","cleanNode","isFunction","panic","error","callOrAssign","constructor","dashToCamelCase","string","replace","_","toUpperCase","noop","writable","configurable","defineProperties","properties","domToArray","els","isArray","toString","normalize","attrs","props","prop","setAttribute","names","parseNodes","getName","element","toLowerCase","$","ctx","querySelectorAll","CSS_BY_NAME","getStyleNode","style","head","cssManager","css","inject","join","COMPONENT_CORE_HELPERS","COMPONENT_LIFECYCLE_METHODS","shouldUpdate","onBeforeMount","onMounted","onBeforeUpdate","onUpdated","onBeforeUnmount","onUnmounted","MOCKED_TEMPLATE_INTERFACE","createComponent","templateFn","components","componentTemplateFactory","camelToDashCase","createSubcomponents","componentAPI","defineComponent","state","preserveRoot","add","curry","_len","arguments","_key","_len2","args","_key2","enhanceComponentAPI","defaults","evaluateProps","attributeExpressions","DOMattributesToObject","computeState","oldState","newState","initialProps","runPlugins","updateValues","createAttributeBindings","addCssHook","newProps","filter","DOM_COMPONENT_INSTANCE_PROPERTY$1","COMPONENTS_IMPLEMENTATION_MAP$1","PLUGINS_SET$1","implementation","fns","f","compose","MediaView","imageUrl","interval","updateImage","urls","cycleImages","duration","startIndex","clearInterval","currentImageIndex","setInterval","imageUrlSuffixed","Date","now","content_app","theComponent","plugin","app","Content","Carousel","carousel","Settings","media","getConfig","Nav","appData","App","mountApp"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"js/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","// Best place to find information on XHR features is:\n// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n\nvar reqfields = [\n  'responseType', 'withCredentials', 'timeout', 'onprogress'\n]\n\n// Simple and small ajax function\n// Takes a parameters object and a callback function\n// Parameters:\n//  - url: string, required\n//  - headers: object of `{header_name: header_value, ...}`\n//  - body:\n//      + string (sets content type to 'application/x-www-form-urlencoded' if not set in headers)\n//      + FormData (doesn't set content type so that browser will set as appropriate)\n//  - method: 'GET', 'POST', etc. Defaults to 'GET' or 'POST' based on body\n//  - cors: If your using cross-origin, you will need this true for IE8-9\n//\n// The following parameters are passed onto the xhr object.\n// IMPORTANT NOTE: The caller is responsible for compatibility checking.\n//  - responseType: string, various compatability, see xhr docs for enum options\n//  - withCredentials: boolean, IE10+, CORS only\n//  - timeout: long, ms timeout, IE8+\n//  - onprogress: callback, IE10+\n//\n// Callback function prototype:\n//  - statusCode from request\n//  - response\n//    + if responseType set and supported by browser, this is an object of some type (see docs)\n//    + otherwise if request completed, this is the string text of the response\n//    + if request is aborted, this is \"Abort\"\n//    + if request times out, this is \"Timeout\"\n//    + if request errors before completing (probably a CORS issue), this is \"Error\"\n//  - request object\n//\n// Returns the request object. So you can call .abort() or other methods\n//\n// DEPRECATIONS:\n//  - Passing a string instead of the params object has been removed!\n//\nexports.ajax = function (params, callback) {\n  // Any variable used more than once is var'd here because\n  // minification will munge the variables whereas it can't munge\n  // the object access.\n  var headers = params.headers || {}\n    , body = params.body\n    , method = params.method || (body ? 'POST' : 'GET')\n    , called = false\n\n  var req = getRequest(params.cors)\n\n  function cb(statusCode, responseText) {\n    return function () {\n      if (!called) {\n        callback(req.status === undefined ? statusCode : req.status,\n                 req.status === 0 ? \"Error\" : (req.response || req.responseText || responseText),\n                 req)\n        called = true\n      }\n    }\n  }\n\n  req.open(method, params.url, true)\n\n  var success = req.onload = cb(200)\n  req.onreadystatechange = function () {\n    if (req.readyState === 4) success()\n  }\n  req.onerror = cb(null, 'Error')\n  req.ontimeout = cb(null, 'Timeout')\n  req.onabort = cb(null, 'Abort')\n\n  if (body) {\n    setDefault(headers, 'X-Requested-With', 'XMLHttpRequest')\n\n    if (!global.FormData || !(body instanceof global.FormData)) {\n      setDefault(headers, 'Content-Type', 'application/x-www-form-urlencoded')\n    }\n  }\n\n  for (var i = 0, len = reqfields.length, field; i < len; i++) {\n    field = reqfields[i]\n    if (params[field] !== undefined)\n      req[field] = params[field]\n  }\n\n  for (var field in headers)\n    req.setRequestHeader(field, headers[field])\n\n  req.send(body)\n\n  return req\n}\n\nfunction getRequest(cors) {\n  // XDomainRequest is only way to do CORS in IE 8 and 9\n  // But XDomainRequest isn't standards-compatible\n  // Notably, it doesn't allow cookies to be sent or set by servers\n  // IE 10+ is standards-compatible in its XMLHttpRequest\n  // but IE 10 can still have an XDomainRequest object, so we don't want to use it\n  if (cors && global.XDomainRequest && !/MSIE 1/.test(navigator.userAgent))\n    return new XDomainRequest\n  if (global.XMLHttpRequest)\n    return new XMLHttpRequest\n}\n\nfunction setDefault(obj, key, value) {\n  obj[key] = obj[key] || value\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/* Riot v4.1.1, @license MIT */\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n      PLUGINS_SET = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY,\n  PLUGINS_SET: PLUGINS_SET,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nfunction cleanNode(node) {\n  const children = node.childNodes;\n  Array.from(children).forEach(n => node.removeChild(n));\n}\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n/* get rid of the @ungap/essential-map polyfill */\n\nconst append = (get, parent, children, start, end, before) => {\n  if (end - start < 2) parent.insertBefore(get(children[start], 1), before);else {\n    const fragment = parent.ownerDocument.createDocumentFragment();\n\n    while (start < end) fragment.appendChild(get(children[start++], 1));\n\n    parent.insertBefore(fragment, before);\n  }\n};\n\nconst eqeq = (a, b) => a == b;\n\nconst identity = O => O;\n\nconst indexOf = (moreNodes, moreStart, moreEnd, lessNodes, lessStart, lessEnd, compare) => {\n  const length = lessEnd - lessStart;\n  /* istanbul ignore if */\n\n  if (length < 1) return -1;\n\n  while (moreEnd - moreStart >= length) {\n    let m = moreStart;\n    let l = lessStart;\n\n    while (m < moreEnd && l < lessEnd && compare(moreNodes[m], lessNodes[l])) {\n      m++;\n      l++;\n    }\n\n    if (l === lessEnd) return moreStart;\n    moreStart = m + 1;\n  }\n\n  return -1;\n};\n\nconst isReversed = (futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare) => {\n  while (currentStart < currentEnd && compare(currentNodes[currentStart], futureNodes[futureEnd - 1])) {\n    currentStart++;\n    futureEnd--;\n  }\n\n  return futureEnd === 0;\n};\n\nconst next = (get, list, i, length, before) => i < length ? get(list[i], 0) : 0 < i ? get(list[i - 1], -0).nextSibling : before;\n\nconst remove = (get, parent, children, start, end) => {\n  if (end - start < 2) parent.removeChild(get(children[start], -1));else {\n    const range = parent.ownerDocument.createRange();\n    range.setStartBefore(get(children[start], -1));\n    range.setEndAfter(get(children[end - 1], -1));\n    range.deleteContents();\n  }\n}; // - - - - - - - - - - - - - - - - - - -\n// diff related constants and utilities\n// - - - - - - - - - - - - - - - - - - -\n\n\nconst DELETION = -1;\nconst INSERTION = 1;\nconst SKIP = 0;\nconst SKIP_OND = 50;\n\nconst HS = (futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges) => {\n  let k = 0;\n  /* istanbul ignore next */\n\n  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;\n  const link = Array(minLen++);\n  const tresh = Array(minLen);\n  tresh[0] = -1;\n\n  for (let i = 1; i < minLen; i++) tresh[i] = currentEnd;\n\n  const keymap = new Map();\n\n  for (let i = currentStart; i < currentEnd; i++) keymap.set(currentNodes[i], i);\n\n  for (let i = futureStart; i < futureEnd; i++) {\n    const idxInOld = keymap.get(futureNodes[i]);\n\n    if (idxInOld != null) {\n      k = findK(tresh, minLen, idxInOld);\n      /* istanbul ignore else */\n\n      if (-1 < k) {\n        tresh[k] = idxInOld;\n        link[k] = {\n          newi: i,\n          oldi: idxInOld,\n          prev: link[k - 1]\n        };\n      }\n    }\n  }\n\n  k = --minLen;\n  --currentEnd;\n\n  while (tresh[k] > currentEnd) --k;\n\n  minLen = currentChanges + futureChanges - k;\n  const diff = Array(minLen);\n  let ptr = link[k];\n  --futureEnd;\n\n  while (ptr) {\n    const {\n      newi,\n      oldi\n    } = ptr;\n\n    while (futureEnd > newi) {\n      diff[--minLen] = INSERTION;\n      --futureEnd;\n    }\n\n    while (currentEnd > oldi) {\n      diff[--minLen] = DELETION;\n      --currentEnd;\n    }\n\n    diff[--minLen] = SKIP;\n    --futureEnd;\n    --currentEnd;\n    ptr = ptr.prev;\n  }\n\n  while (futureEnd >= futureStart) {\n    diff[--minLen] = INSERTION;\n    --futureEnd;\n  }\n\n  while (currentEnd >= currentStart) {\n    diff[--minLen] = DELETION;\n    --currentEnd;\n  }\n\n  return diff;\n}; // this is pretty much the same petit-dom code without the delete map part\n// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561\n\n\nconst OND = (futureNodes, futureStart, rows, currentNodes, currentStart, cols, compare) => {\n  const length = rows + cols;\n  const v = [];\n  let d, k, r, c, pv, cv, pd;\n\n  outer: for (d = 0; d <= length; d++) {\n    /* istanbul ignore if */\n    if (d > SKIP_OND) return null;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n\n      r = c - k;\n\n      while (c < cols && r < rows && compare(currentNodes[currentStart + c], futureNodes[futureStart + r])) {\n        c++;\n        r++;\n      }\n\n      if (c === cols && r === rows) {\n        break outer;\n      }\n\n      cv[d + k] = c;\n    }\n  }\n\n  const diff = Array(d / 2 + length / 2);\n  let diffIdx = diff.length - 1;\n\n  for (d = v.length - 1; d >= 0; d--) {\n    while (c > 0 && r > 0 && compare(currentNodes[currentStart + c - 1], futureNodes[futureStart + r - 1])) {\n      // diagonal edge = equality\n      diff[diffIdx--] = SKIP;\n      c--;\n      r--;\n    }\n\n    if (!d) break;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n\n    if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n    }\n  }\n\n  return diff;\n};\n\nconst applyDiff = (diff, get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before) => {\n  const live = new Map();\n  const length = diff.length;\n  let currentIndex = currentStart;\n  let i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        futureStart++;\n        currentIndex++;\n        break;\n\n      case INSERTION:\n        // TODO: bulk appends for sequential nodes\n        live.set(futureNodes[futureStart], 1);\n        append(get, parentNode, futureNodes, futureStart++, futureStart, currentIndex < currentLength ? get(currentNodes[currentIndex], 0) : before);\n        break;\n\n      case DELETION:\n        currentIndex++;\n        break;\n    }\n  }\n\n  i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        currentStart++;\n        break;\n\n      case DELETION:\n        // TODO: bulk removes for sequential nodes\n        if (live.has(currentNodes[currentStart])) currentStart++;else remove(get, parentNode, currentNodes, currentStart++, currentStart);\n        break;\n    }\n  }\n};\n\nconst findK = (ktr, length, j) => {\n  let lo = 1;\n  let hi = length;\n\n  while (lo < hi) {\n    const mid = (lo + hi) / 2 >>> 0;\n    if (j < ktr[mid]) hi = mid;else lo = mid + 1;\n  }\n\n  return lo;\n};\n\nconst smartDiff = (get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before) => {\n  applyDiff(OND(futureNodes, futureStart, futureChanges, currentNodes, currentStart, currentChanges, compare) || HS(futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges), get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before);\n};\n/*! (c) 2018 Andrea Giammarchi (ISC) */\n\n\nconst domdiff = (parentNode, // where changes happen\ncurrentNodes, // Array of current items/nodes\nfutureNodes, // Array of future items/nodes\noptions // optional object with one of the following properties\n//  before: domNode\n//  compare(generic, generic) => true if same generic\n//  node(generic) => Node\n) => {\n  if (!options) options = {};\n  const compare = options.compare || eqeq;\n  const get = options.node || identity;\n  const before = options.before == null ? null : get(options.before, 0);\n  const currentLength = currentNodes.length;\n  let currentEnd = currentLength;\n  let currentStart = 0;\n  let futureEnd = futureNodes.length;\n  let futureStart = 0; // common prefix\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentStart], futureNodes[futureStart])) {\n    currentStart++;\n    futureStart++;\n  } // common suffix\n\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])) {\n    currentEnd--;\n    futureEnd--;\n  }\n\n  const currentSame = currentStart === currentEnd;\n  const futureSame = futureStart === futureEnd; // same list\n\n  if (currentSame && futureSame) return futureNodes; // only stuff to add\n\n  if (currentSame && futureStart < futureEnd) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentStart, currentLength, before));\n    return futureNodes;\n  } // only stuff to remove\n\n\n  if (futureSame && currentStart < currentEnd) {\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  }\n\n  const currentChanges = currentEnd - currentStart;\n  const futureChanges = futureEnd - futureStart;\n  let i = -1; // 2 simple indels: the shortest sequence is a subsequence of the longest\n\n  if (currentChanges < futureChanges) {\n    i = indexOf(futureNodes, futureStart, futureEnd, currentNodes, currentStart, currentEnd, compare); // inner diff\n\n    if (-1 < i) {\n      append(get, parentNode, futureNodes, futureStart, i, get(currentNodes[currentStart], 0));\n      append(get, parentNode, futureNodes, i + currentChanges, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n      return futureNodes;\n    }\n  }\n  /* istanbul ignore else */\n  else if (futureChanges < currentChanges) {\n      i = indexOf(currentNodes, currentStart, currentEnd, futureNodes, futureStart, futureEnd, compare); // outer diff\n\n      if (-1 < i) {\n        remove(get, parentNode, currentNodes, currentStart, i);\n        remove(get, parentNode, currentNodes, i + futureChanges, currentEnd);\n        return futureNodes;\n      }\n    } // common case with one replacement for many nodes\n  // or many nodes replaced for a single one\n\n  /* istanbul ignore else */\n\n\n  if (currentChanges < 2 || futureChanges < 2) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, get(currentNodes[currentStart], 0));\n    remove(get, parentNode, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  } // the half match diff part has been skipped in petit-dom\n  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397\n  // accordingly, I think it's safe to skip in here too\n  // if one day it'll come out like the speediest thing ever to do\n  // then I might add it in here too\n  // Extra: before going too fancy, what about reversed lists ?\n  //        This should bail out pretty quickly if that's not the case.\n\n\n  if (currentChanges === futureChanges && isReversed(futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare)) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n    return futureNodes;\n  } // last resort through a smart diff\n\n\n  smartDiff(get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before);\n  return futureNodes;\n};\n\nconst EachBinding = Object.seal({\n  // dynamic binding properties\n  childrenMap: null,\n  node: null,\n  root: null,\n  condition: null,\n  evaluate: null,\n  template: null,\n  nodes: [],\n  getKey: null,\n  indexName: null,\n  itemName: null,\n  afterPlaceholder: null,\n  placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder\n    } = this;\n    const collection = this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n    const parent = placeholder.parentNode; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    if (futureNodes.length) {\n      domdiff(parent, this.nodes, futureNodes, {\n        before: placeholder,\n        node: patch(Array.from(this.childrenMap.values()), parentScope)\n      });\n    } else {\n      // remove all redundant templates\n      unmountRedundant(this.childrenMap);\n    } // trigger the mounts and the updates\n\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    unmountRedundant(this.childrenMap, parentScope);\n    this.childrenMap = new Map();\n    this.nodes = [];\n    return this;\n  }\n\n});\n/**\n * Patch the DOM while diffing\n * @param   {TemplateChunk[]} redundant - redundant tepmplate chunks\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      const {\n        template,\n        context\n      } = redundant.pop(); // notice that we pass null as last argument because\n      // the root node and its children will be removed by domdiff\n\n      template.unmount(context, parentScope, null);\n    }\n\n    return item;\n  };\n}\n/**\n * Unmount the remaining template instances\n * @param   {Map} childrenMap - map containing the children template to unmount\n * @param   {*} parentScope - scope of the parent template\n * @returns {TemplateChunk[]} collection containing the template chunks unmounted\n */\n\n\nfunction unmountRedundant(childrenMap, parentScope) {\n  return Array.from(childrenMap.values()).map((_ref) => {\n    let {\n      template,\n      context\n    } = _ref;\n    return template.unmount(context, parentScope, true);\n  });\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? Boolean(condition(context)) === false : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref2) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref2;\n  scope[itemName] = item;\n  if (indexName) scope[indexName] = index;\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EeachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = oldItem ? componentTemplate.el : root.cloneNode();\n\n    if (!oldItem) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n\n\n    futureNodes.push(el); // delete the old item from the children map\n\n    childrenMap.delete(key); // update the children map\n\n    newChildrenMap.set(key, {\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create(node, _ref3) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref3;\n  const placeholder = document.createTextNode('');\n  const parent = node.parentNode;\n  const root = node.cloneNode();\n  const offset = Array.from(parent.childNodes).indexOf(node);\n  parent.insertBefore(placeholder, node);\n  parent.removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    offset,\n    condition,\n    evaluate,\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n/**\n * Binding responsible for the `if` directive\n */\n\n\nconst IfBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  placeholder: null,\n  template: '',\n\n  // API methods\n  mount(scope, parentScope) {\n    swap(this.placeholder, this.node);\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    switch (true) {\n      case mustMount:\n        swap(this.node, this.placeholder);\n\n        if (this.template) {\n          this.template = this.template.clone();\n          this.template.mount(this.node, scope, parentScope);\n        }\n\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        swap(this.placeholder, this.node);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    const {\n      template\n    } = this;\n\n    if (template) {\n      template.unmount(scope, parentScope);\n    }\n\n    return this;\n  }\n\n});\n\nfunction swap(inNode, outNode) {\n  const parent = outNode.parentNode;\n  parent.insertBefore(inNode, outNode);\n  parent.removeChild(outNode);\n}\n\nfunction create$1(node, _ref4) {\n  let {\n    evaluate,\n    template\n  } = _ref4;\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder: document.createTextNode(''),\n    template: template.createDOM(node)\n  });\n}\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst SET_ATTIBUTE = 'setAttribute';\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach((_ref5) => {\n    let [name, value] = _ref5;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing all the attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, attributes) {\n  Object.keys(attributes).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref6, value, oldValue) {\n  let {\n    name\n  } = _ref6;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    } else if (oldValue) {\n      // otherwise remove all the old attributes\n      removeAllAttributes(node, oldValue);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (typeof value === 'boolean') {\n    node[name] = value;\n  }\n\n  node[getMethod(value)](name, normalizeValue(name, value));\n}\n/**\n * Get the attribute modifier method\n * @param   {*} value - if truthy we return `setAttribute` othewise `removeAttribute`\n * @returns {string} the node attribute modifier method name\n */\n\n\nfunction getMethod(value) {\n  return value && typeof value !== 'object' ? SET_ATTIBUTE : REMOVE_ATTRIBUTE;\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  if (value === true) return name;\n  return value;\n}\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction eventExpression(node, _ref7, value) {\n  let {\n    name\n  } = _ref7;\n  node[name] = value;\n}\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {number} expression.childNodeIndex - index to find the text node to update\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction textExpression(node, _ref8, value) {\n  let {\n    childNodeIndex\n  } = _ref8;\n  const target = node.childNodes[childNodeIndex];\n  const val = normalizeValue$1(value); // replace the target if it's a placeholder comment\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode(val);\n    node.replaceChild(textNode, target);\n  } else {\n    target.data = normalizeValue$1(val);\n  }\n}\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\n\nfunction normalizeValue$1(value) {\n  return value != null ? value : '';\n}\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\n\nfunction valueExpression(node, expression, value) {\n  node.value = value;\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\nconst Expression = Object.seal({\n  // Static props\n  node: null,\n  value: null,\n\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    return this;\n  }\n\n});\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$2(node, data) {\n  return Object.assign({}, Expression, data, {\n    node\n  });\n}\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\n\n\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref9) {\n  let {\n    expressions\n  } = _ref9;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$2(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nconst SlotBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  name: null,\n  template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find((_ref10) => {\n      let {\n        id\n      } = _ref10;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    this.template = templateData && create$6(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      this.template.mount(this.node, parentScope);\n      moveSlotInnerContent(this.node);\n    }\n\n    parentNode.removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template && parentScope) {\n      this.template.update(parentScope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    if (this.template) {\n      this.template.unmount(parentScope);\n    }\n\n    return this;\n  }\n\n});\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLNode} slot - slot node\n * @returns {undefined} it's a void function\n */\n\nfunction moveSlotInnerContent(slot) {\n  if (slot.firstChild) {\n    slot.parentNode.insertBefore(slot.firstChild, slot);\n    moveSlotInnerContent(slot);\n  }\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} options.name - slot id\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref11) {\n  let {\n    name\n  } = _ref11;\n  return Object.assign({}, SlotBinding, {\n    node,\n    name\n  });\n}\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create$6(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref12) => {\n    let {\n      bindings\n    } = _ref12;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = Object.seal({\n  // dynamic binding properties\n  node: null,\n  evaluate: null,\n  name: null,\n  slots: null,\n  tag: null,\n  attributes: null,\n  getComponent: null,\n\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount() {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(true);\n    }\n\n    return this;\n  }\n\n});\n\nfunction create$4(node, _ref13) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref13;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$1,\n  [SIMPLE]: create$3,\n  [EACH]: create,\n  [TAG]: create$4,\n  [SLOT]: createSlot\n};\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {Object} binding - binding data\n * @returns {Expression} Expression object\n */\n\nfunction create$5(root, binding) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute); // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: expressions || []\n  }));\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n} // in this case a simple innerHTML is enough\n\n\nfunction createHTMLTree(html) {\n  const template = document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction creteSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return creteSVGTree(html, root);\n  return createHTMLTree(html);\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method \\_()_/\n */\n// Ignore this helper because it's needed only for svg tags\n\n/* istanbul ignore next */\n\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n\nconst SVG_RE = /svg/i;\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {HTMLFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  if (SVG_RE.test(el.tagName)) {\n    moveChildren(dom, el);\n  } else {\n    el.appendChild(dom);\n  }\n}\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string} html - markup that will be injected into the root node\n * @returns {HTMLFragment} fragment that will be injected into the root node\n */\n\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  bindings: null,\n  bindingsData: null,\n  html: null,\n  dom: null,\n  el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html);\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope) {\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope);\n    this.el = el; // create the DOM if it wasn't created before\n\n    this.createDOM(el);\n    if (this.dom) injectDOM(el, this.dom.cloneNode(true)); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$5(this.el, binding));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean} mustRemoveRoot - if true remove the root element\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.el) {\n      this.bindings.forEach(b => b.unmount(scope, parentScope));\n\n      if (mustRemoveRoot && this.el.parentNode) {\n        this.el.parentNode.removeChild(this.el);\n      } else if (mustRemoveRoot !== null) {\n        cleanNode(this.el);\n      }\n\n      this.el = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {Array} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create$6(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n\n/* eslint-disable fp/no-mutating-methods */\n/**\n * Throw an error\n * @param {string} error - error message\n * @returns {undefined} it's a IO void function\n */\n\nfunction panic(error) {\n  throw new Error(error);\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\n\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach((_ref) => {\n    let [key, value] = _ref;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n} // doese simply nothing\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\n\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach((_ref2) => {\n    let [key, value] = _ref2;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === expressionTypes.ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n\n      case type === expressionTypes.VALUE:\n        acc[VALUE_ATTRIBUTE] = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  shouldUpdate: noop,\n  onBeforeMount: noop,\n  onMounted: noop,\n  onBeforeUpdate: noop,\n  onUpdated: noop,\n  onBeforeUnmount: noop,\n  onUnmounted: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = {\n  update: noop,\n  mount: noop,\n  unmount: noop,\n  clone: noop,\n  createDOM: noop\n  /**\n   * Factory function to create the component templates only once\n   * @param   {Function} template - component template creation function\n   * @param   {Object} components - object containing the nested components\n   * @returns {TemplateChunk} template chunk object\n   */\n\n};\n\nfunction componentTemplateFactory(template, components) {\n  return template(create$6, expressionTypes, bindingTypes, name => {\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {string} options.css - component css\n * @param   {Function} options.template - functon that will return the dom-bindings template function\n * @param   {Object} options.exports - component interface\n * @param   {string} options.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(_ref) {\n  let {\n    css,\n    template,\n    exports,\n    name\n  } = _ref;\n  const templateFn = template ? componentTemplateFactory(template, exports ? createSubcomponents(exports.components) : {}) : MOCKED_TEMPLATE_INTERFACE;\n  return (_ref2) => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    state: {}\n  })), Object.assign({\n    // defined during the component creation\n    slots: null,\n    root: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Evaluate the component properties either from its real attributes or from its attribute expressions\n * @param   {HTMLElement} element - component root\n * @param   {Array}  attributeExpressions - attribute values generated via createAttributeBindings\n * @returns {Object} attributes key value pairs\n */\n\nfunction evaluateProps(element, attributeExpressions) {\n  if (attributeExpressions === void 0) {\n    attributeExpressions = [];\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), evaluateAttributeExpressions(attributeExpressions));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$2(node, a));\n  const binding = {};\n\n  const updateValues = method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  };\n\n  return Object.assign(binding, {\n    expressions,\n    mount: updateValues('mount'),\n    update: updateValues('update'),\n    unmount: updateValues('unmount')\n  });\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, 'is', name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  const initialProps = callOrAssign(props);\n  return autobindMethods(runPlugins(defineProperties(Object.create(component), {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      this.props = Object.freeze(Object.assign({}, initialProps, evaluateProps(element, this[ATTRIBUTES_KEY_SYMBOL].expressions)));\n      this.state = computeState(this.state, state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      element[DOM_COMPONENT_INSTANCE_PROPERTY] = this; // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, 'root', element); // define the slots array\n\n      defineProperty(this, 'slots', slots); // before mount lifecycle event\n\n      this.onBeforeMount(this.props, this.state); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this.onMounted(this.props, this.state);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateProps(this.root, this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this.shouldUpdate(newProps, this.props) === false) return;\n      this.props = Object.freeze(Object.assign({}, initialProps, newProps));\n      this.state = computeState(this.state, state);\n      this.onBeforeUpdate(this.props, this.state);\n      this[TEMPLATE_KEY_SYMBOL].update(this, parentScope);\n      this.onUpdated(this.props, this.state);\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this.onBeforeUnmount(this.props, this.state);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount();\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, {}, !preserveRoot);\n      this.onUnmounted(this.props, this.state);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  PLUGINS_SET: PLUGINS_SET$1\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of nodes upgraded\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY$1]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY$1].unmount();\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET$1.has(plugin)) panic('This plugin was already install');\n  PLUGINS_SET$1.add(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET$1.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET$1.delete(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Helpter method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return (el, props) => compose(c => c.mount(el), c => c({\n    props\n  }), createComponent)(implementation);\n}\n/** @type {string} current riot version */\n\nconst version = 'v4.1.1'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, register, uninstall, unmount, unregister, version };\n","<carousel>\n    <div class=\"row\">\n        <div class=\"col m8 s12 offset-m2 center-align\">\n            <media-view image-url={ state.imageUrlSuffixed } />\n        </div>\n            <div class=\"center-align\">\n                <p>{ state.imageUrl }</p>\n            </div>\n        </div>\n    </div>\n    <script>\n        import MediaView from '../components/media-view/media-view.riot';\n\n        export default {\n            components: {\n                MediaView,\n            },\n            onBeforeMount() {\n            },\n            onMounted() {\n                this.interval = false;\n                this.updateImage(this.props.urls[0]);\n                this.cycleImages(this.props.urls, this.props.duration, 1);\n            },\n            cycleImages(urls, duration, startIndex) {\n                if (this.interval) {\n                    clearInterval(this.interval);\n                }\n                this.currentImageIndex = startIndex;\n\n                this.interval = setInterval(() => {\n                    this.updateImage(urls[this.currentImageIndex]);\n\n                    this.currentImageIndex += 1;\n                    if (urls.length <= this.currentImageIndex) {\n                        this.currentImageIndex = 0;\n                    }\n                }, duration);\n            },\n            updateImage(imageUrl) {\n                const imageUrlSuffixed = `${imageUrl}?d=${Date.now()}`;\n\n                this.update({\n                    imageUrl,\n                    imageUrlSuffixed,\n                });\n            },\n        };\n    </script>\n</carousel>\n","<media-view>\n    <img src={ props.imageUrl }>\n</media-view>\n","<content>\n    <p>{ getConfig('basicText') }</p>\n    <section>\n        <carousel app={ props.app } urls={ state.urls } duration={ state.duration }></carousel>\n    </section>\n    <section>\n        <settings app={ props.app }></settings>\n    </section>\n    <script>\n        import Carousel from '../carousel/carousel.riot';\n        import Settings from '../settings/settings.riot';\n        import nanoajax from 'nanoajax';\n\n        let app;\n\n        /**\n         * FetchUrlList\n         * Fetches a list of URLs for the configured disk\n         * @return {Promise}\n         */\n        const fetchUrlList = () => new Promise((resolve) => {\n            nanoajax.ajax({\n                url: 'https://picsum.photos/v2/list',\n            }, (code, body) => {\n                if (code >= 300) {\n                    return reject();\n                }\n\n                const urls = [];\n                const urlList = JSON.parse(body);\n                urlList.forEach((item) => {\n                    urls.push(`${item.download_url}.jpg`);\n                });\n\n                resolve(urls);\n            });\n        });\n\n        export default {\n            components: {\n                Carousel,\n                Settings,\n            },\n            onBeforeMount() {\n                app = this.props.app;\n                app.media = {\n                    urls: [],\n                    duration: this.getConfig('duration'),\n                };\n                this.state.urls = [\n                    'https://picsum.photos/id/1/200/300.jpg',\n                    'https://picsum.photos/id/2/200/300.jpg',\n                    'https://picsum.photos/id/3/200/300.jpg',\n                ];\n                this.state.duration = 3000;\n            },\n            onMounted() {\n                const self = this;\n                /*\n                fetchUrlList\n                    .then((urls) => {\n                        this.update({ urls });\n                    });\n                    */\n            },\n        };\n    </script>\n</content>\n","let theComponent;\n\n/**\n * GetConfig\n * Gets the value of a config field, or null if it does not exist\n *\n * @param {string} name - The name of the config value\n * @return {mixed} - The value\n */\nconst getConfig = (name) => {\n    const { app } = theComponent.props;\n    return app.data && app.data.options && typeof app.data.options[name] !== 'undefined'\n        ? app.data.options[name]\n        : null;\n};\n\n/**\n * Plugin\n * The plugin\n *\n * @param {object} component - The component\n * @return {object} component - The modified component\n */\nconst plugin = (component) => {\n    theComponent = component;\n    component.getConfig = getConfig;\n\n    return component;\n};\n\nexport default plugin;\n","// NPM Dependencies\nimport { component, install } from 'riot';\nimport App from '../components/app/app.riot';\nimport configHelper from '../plugins/config-plugin.js';\n\n// Initialize\n((window, data) => {\n    const app = {\n        data\n    };\n\n    // Install helpers\n    install(configHelper);\n\n    // Register the app component.\n    const mountApp = component(App);\n\n    // Add the <app> tag and mount it.\n    const rootEl = document.body.appendChild(document.createElement('app'));\n    mountApp(rootEl, { app });\n})(window, appData);\n","<app>\n    <div class=\"main\">\n        <header>\n            <nav is=\"nav\" app={ props.app }></nav>\n        </header>\n        <main>\n            <div id=\"main-container\" class=\"container\">\n                <content app={ props.app }></content>\n            </div>\n        </main>\n        <footer>\n        </footer>\n    </div>\n    <script>\n        import Content from '../content/content.riot';\n        import Nav from '../nav/nav.riot';\n\n        export default {\n            components: {\n                Content,\n                Nav,\n            },\n        };\n    </script>\n</app>\n"],"sourceRoot":""}